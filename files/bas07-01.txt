c1E
ГЛАВА  VII.  ДОПОЛНИТЕЛЬНЫЕ  ВОЗМОЖНОСТИ  ЯЗЫКА  MSX-BASIC



                       VII.1.  РАБОТА С КЛАВИАТУРОЙ


  VII.1.1.   Н е с т а н д а р т н ы й   в в о д   с  к л а в и а т у р ы


   Как правило, ввод данных с клавиатуры пользователь осуществляет с помо-
щью оператора INPUT. При этом нужно нажать как минимум две  клавиши: одну
для ввода символа и вторую для помещения его в память. При этом  знак  во-
проса ("подсказка") и вводимый символ ("эхо") отображаются на экране.
   Строковая функция INKEY$ подавляет "подсказку" и "эхо" символа на экра-
не и не требует нажатия клавиши ввода ("RETURN").
   Функция                 ┌───────────────┐
                           │     INKEY$    │ ,
                           └───────────────┘
где INKEY ("KEY IN" - "вводить с клавиатуры") - служебное слово,
в момент нажатия на какую-либо клавишу возвращает значение, равное  вводи-
мому по ней символу. Если клавиша не нажата, то  значением функции INKEY$
является пустая строка ("").

   П р и м е р  1.
   ──────────────
   10 W$=INKEY$:IF W$="" THEN 10 'Если клавиша не нажата, то компьютер пе-
   реходит к выполнению строки с номером 10.
   20 PRINT W$:GOTO 10 'Вывод на экран символа, соответствующего нажатой
   клавише,и переход к выполнению строки 10.
   run
   a     ◀── нажата клавиша "a"
   p    │   
   r    │   
   i    │◀── нажата клавиша "F1" (для компьютера MSX-1)
   n    │   
   t    │    
        │
   █     ◀── нажата клавиша "STOP"
   Break in 10  ◀──  нажаты клавиши "CTRL"+"STOP"
   Ok

   При выполнении программы клавиатура постоянно опрашивается  (сканирует-
ся), и полученные коды записываются в область памяти, называемую  б у ф е-
р о м   клавиатуры. Функция INKEY$, как Вы только что  увидели, извлекает
из буфера клавиатуры код набранного символа. Если  буфер  "пуст" (никакая
клавиша не нажата!), то функция INKEY$ возвращает пустую строку.
┌──────────────────────────────────────────────────────────────────────┐
│  Важной особенностью функции INKEY$ является то, что она не выводит  │
│  на экран символ, набранный на клавиатуре (если, конечно, в програм- │
│  ме отсутствует оператор PRINT !), и не "ожидает" ввода символа, ес- │
│                      ли клавиша не нажата                            │
└──────────────────────────────────────────────────────────────────────┘
   С помощью функции INKEY$ можно "прочитать" нажатие только  тех  клавиш,
которым соответствует код какого-либо символа. Это делается так:
                       IF INKEY$="с и м в о л" THEN ...
   Далее, для обнаружения нажатия какой-либо из клавиш:
    ┌──────────────────────────────────────────────────────────────┐
    │  "ESC", "TAB", "RETURN", "SELECT", "HOME/CLS", "INS","DEL",  │
    │          клавиши управления курсором, "CTRL+буква"           │
    └──────────────────────────────────────────────────────────────┘
используйте оператор:
                          IF INKEY$=CHR$(K) THEN ... 
где  К - код клавиши, нажатия которой ожидается.
   К сожалению, клавиши
         ┌─────────────────────────────────────────────────────┐
         │   "CAPS", "SHIFT", "GRAPH", "CTRL", "РУС", "STOP"   │
         └─────────────────────────────────────────────────────┘
"нечитаемы" операторами INPUT$ или INKEY$. Тем не менее, для чтения  этих
клавиш достаточно прочесть буфер NEWKEY (11 байтов) по адресу &HFBE5 (см.
раздел X.9.1).

   П р и м е р  2. Пример  программы,  останавливаемой  нажатием  клавиши
   ──────────────  "SHIFT":       10 Z=PEEK(&HFBEB):IF Z<>254 THEN 10

   П р и м е р  3. Вспомним, что функция ASC(α), где α - строковое выраже-
   ──────────────  ние, возвращает десятичный код ASCII  первого  символа
значения выражения α. Используя функцию INKEY$, можно получать десятичные
коды ASCII "печатаемых" символов и некоторых управляющих клавиш.  Интерес-
ны результаты нажатия функциональных клавиш.
   10 W$=INKEY$:IF W$="" THEN 10 ELSE PRINT ASC(W$):GOTO 10
   run
    27  ◀── нажата клавиша "ESC"        112 │
    112 ◀── нажата клавиша "p"          114 │
    114 ◀── нажата клавиша "r"          105 │ ◀── нажата клавиша "F1"
    105 ◀── нажата клавиша "i"          110 │
    110 ◀── нажата клавиша "n"          116 │
    116 ◀── нажата клавиша "t"          32  │
    32  ◀── нажата клавиша "пробел"    Break in 10◀── нажаты клавиши"CTRL"
   █    ◀── нажата клавиша "STOP"      Ok              +"STOP"
    49  ◀── нажата клавиша "SHIFT"+"1"

   Таким образом,  функциональные клавиши имеют ту особенность,  что нажа-
тие любой из них вызывает вывод кодов  нескольких символов,  составляющих
ее текст.
   Приведем еще один пример применения функции INKEY$.
    10 PRINT "Нажмите любую клавишу для продолжения"
    20 IF INKEY$="" THEN 20   'Задержка до нажатия клавиши
                           ┌────────────────┐
   Функция                 │    INPUT$(n)   │
                           └────────────────┘
служит для получения  n последовательно вводимых  с  клавиатуры  символов.
Вводимые символы "накапливаются" в буфере клавиатуры без  изображения  их  
на экране дисплея. Когда ввод окончен (время ввода  не  ограничено!),  то 
функция INPUT$() возвращает на экран дисплея строку введенных символов  и
курсор.
  ┌──────────────────────────────────────────────────────────────────┐
  │   Запомните, что только нажатие клавиш "CTRL"+"STOP" прерывает   │
  │                    действие данной функции!                      │
  └──────────────────────────────────────────────────────────────────┘

   П р и м е р  4.    10 W$=INPUT$(2):?W$:GOTO 10
   ──────────────     run
                      █
                      █   ◀── нажата клавиша "a"
                      ar  ◀── нажата клавиша "r"
                      █
                      Break in 10  ◀── нажаты клавиши "CTRL"+"STOP"
                      Ok

   Этот оператор неудобно использовать  для ввода  д л и н н ы х  символь-
ных строк с клавиатуры, ибо Вы можете потерять контроль над  вводом  (вве-
денные символы не видны на экране до тех пор, пока не введен последний из
них).
   Однако можно использовать функцию  INPUT$(1) для ввода с клавиатуры по
одному символу (аналогично функции INKEY$).

   П р и м е р  5.
   ──────────────
   1) 10 W$=INPUT$(1):?W$:GOTO10  2) 10 ? ASC(INPUT$(1)):GOTO 10
      run                            run
      █                              █
      a   ◀── нажата клавиша "a"      112  │
      p   ◀── нажата клавиша "p"      114  │
      p  │                            105  │◀── нажата клавиша "F1"
      r  │                            110  │    на компьютере 
      i  │◀── нажата клавиша "F1"     116  │    серии MSX-1
      n  │    на компьютере           32   │
      t  │    серии MSX-1            █
         │                            97 ◀── нажата клавиша "а" 
      █    и так далее...            █       и так далее...

   Таким образом, функцию INPUT$() можно также использовать для получения
десятичных кодов ASCII символов, а также десятичных кодов ASCII некоторых
управляющих и функциональных клавиш.

   П р и м е р  6.   П а р о л ь !
   ──────────────
   40 CODE$="Секрет":COUNT=0:PRINT"Имя":INPUT N$
   70 PRINT "Пароль:"
   110 P$=INPUT$(6) 'Чтение  ш е с т и  символов
   120 IF P$=CODE$ THEN GOTO 150
   130 COUNT=COUNT+1
   140 IF COUNT<3 THEN GOTO 70 ELSE PRINT"Проход закрыт":END
   150 PRINT:PRINT N$:PRINT"Проходи, приятель":END

   Результат работы программной строки
                       10 A$=INKEY$:IF A$="" THEN 10
может показаться эквивалентным результату работы команды
                               A$=INPUT$(1)                            !
   Однако между ними есть  различиe: нажатие  клавиши  "STOP" задерживает
программу в цикле с оператором INKEY$, тогда как во время  ожидания  нажа-
тия клавиши, "организованного" оператором INPUT$, клавиша "STOP" временно
отключается.
┌───────────────────────────────────────────────────────────────────────┐
│ Это единственный способ временно отключить клавишу "STOP" в MSX-BASIC!│
└───────────────────────────────────────────────────────────────────────┘ 



         VII.1.2.    Ф у н к ц и о н а л ь н ы е  к л а в и ш и 


   При нажатии клавиши "F1" на дисплее компьютера серии  MSX-1 появляется
слово "print" (как если бы оно набиралось на клавиатуре посимвольно). Ана-
логичным образом действует любая из остальных  девяти  функциональных кла-
виш:     "F2" , "F3" , "F4", "F5", "F6", "F7", "F8", "F9" , "F10",-
генерируя на экране соответствующее  слово. Подобные  клавиши  называются
ф у н к ц и о н а л ь н ы м и  (программируемыми), поскольку они не связа-
ны жестко с каким-либо определенным символом. Генерируемые ими слова назы-
ваются  з н а ч е н и я м и  функциональных клавиш.
   MSX-BASIC располагает средством, позволяющим изменять эти значения так,
что при нажатии соответствующей клавиши генерируется заранее заданная  це-
почка символов. Этим средством является оператор
                           ┌──────────────────┐
                           │      KEY n,T     │
                           └──────────────────┘
где:  KEY ("key"-"клавиша") - служебное слово;
      n - арифметическое выражение, целая часть значения которого  задает
номер функциональной клавиши (n=1,2,...,9);
      T - символьное выражение.
   При выполнении данного оператора значение клавиши Fn становится равным
значению символьного выражения T. Длина последнего не должна превышать 15.
В противном случае будут использованы лишь первые 15 символов этого значе-
ния. Отметим, что оператор
                                  KEY n,""
"сбрасывает" значение функциональной клавиши с номером  n.
   Оператор                ┌─────────────────┐
                           │     KEY LIST    │
                           └─────────────────┘
выводит на экран дисплея значения 10 функциональных клавиш по порядку, по
одной на дисплейную строку.
   Приведем ряд  п р и м е р о в:
   1) 10 KEY 1,CHR$(1)+CHR$(78)  2) 10 KEY 5,"print x;y"
      20 KEY LIST
      run                        3) 10 FOR S=1 TO 5:KEY S,"":NEXT: KEY 1,
      ♬          │                  "GOSUB"
      auto       │ для компью-      20 KEY S,"YES":KEY LIST
      goto       │ теров серии
      ···        │   MSX-1       4) 10 X$="for x=1 to 15'заголовок":KEY5,
      _comterm   │                  X$:KEY LIST
      Ok

   5) KEY 2,"LIST"+CHR$(13) 'При нажатии клавиши F2 в ы п о л н я е т с я
команда LIST. Заметим, что символ CHR$(13) вызывает ввод команды (операто-
ра) так же, как и нажатие клавиши "RETURN"!

   Отметим, что при включении компьютера серии MSX-1 значения функциональ-
ных клавиш устанавливаются по умолчанию следующим образом:
   print          auto          goto          list            run
   run"COM:"      save"COM:"    load"COM:"    merge"COM:"     _comterm
Однако, если одновременно нажать на кнопку сброса " RESET " и клавишу DEL,
то ключи будут установлены следующим образом:
   color          auto          goto          list            run
   color 15,4,4   cload"        cont          list.            run
   Кстати,этого состояния функциональных клавиш можно достичь программным
путем. Для этого используйте команды:
                           DEFUSR=&H003E:X=USR(X)                       .
   При помощи функциональных  клавиш можно  значительно ускорить ввод про-
грамм в память компьютера, если "занести в них" часто встречающиеся в про-
грамме служебные слова.
   Использование функциональных клавиш очень полезно  на этапе  р е д а к-
т и р о в а н и я  программы. Каждая из клавиш может быть специально опре-
делена для ускорения набора текста программы.
   Предположим, что Вы хотите ввести  большое  количество  двоичных чисел.
Это часто бывает необходимо при  определении образа спрайта. Чтобы  облег-
чить себе работу, определите одну из функциональных клавиш так:
                       KEY1,"DATA 00000000"+CHR$(13)
а затем введите команду AUTO. Нажмите клавишу "F1" несколько раз для полу-
чения начальных "шаблонов" операторов DATA  с последовательными  номерами
строк. Вам остается только отредактировать те строки, в которых  необходи-
мо заменить нули на единицы в нужных местах!



                         VII.1.3   Д ж о й с т и к 


                   Человеческая изобретательность ни в чем не проявляется
                   так, как в играх.
                                         Из письма Г.В.Лейбница Б.Паскалю


   В комплекте MSX-компьютера имеется два периферийных устройства для вво-
да информации,  которые называются  д ж о й с т и к а м и  ("joy  stick" -
"палочка радости").
   Каждый джойстик состоит из двух блоков: р у к о я т к и   и   к н о п -
к и . Обычно у джойстика имеется одна кнопка. Кроме того, к каждому  джой-
стику можно присоединить дополнительно еще по одной кнопке  (отметим, что
у некоторых моделей их две изначально!).
   Рукоятку джойстика можно перемещать вверх, вниз, направо, налево,а так-
же в комбинациях:  вверх+направо, вверх+налево, вниз+направо, вниз+налево.
Таким образом, получается  в о с е м ь  допустимых направлений движения.
   ┌──────────────────────────────────────────────────────────────────┐
   │   Важно отметить, что MSX-компьютер имеет встроенный "джойстик"  │
   │   (с номером 0). Роль  р у к о я т к и  этого "джойстика" игра-  │
   │    ют клавиши управления курсором, а роль  к н о п к и  играет   │
   │                        клавиша "пробел"!                         │
   └──────────────────────────────────────────────────────────────────┘
   В MSX-BASIC имеется возможность нестандартного ввода информации при по-
мощи джойстика. Делается это при помощи функций STICK(), STRIG(), PDL() и
PAD().
   Формат функции STICK() следующий:
                             ┌───────────────┐
                             │    STICK(α)   │ ,
                             └───────────────┘
где:  STICK ("рукоятка")- служебное слово;
      α - арифметическое выражение, целая часть значения которого  принад-
лежит отрезку [0,2] и задает номер джойстика.

          1             Эта функция возвращает целое число, принадлежащее
      8   ▲   2     отрезку [0,8] и отмечающее направление перемещения ру-
        \ │ /       коятки джойстика, номер которого определяется значени-
   7 ◀──  0 ──▶ 3   ем выражения α. Рисунок слева демонстрирует различные
        / │ \       значения функции  STICK() (когда джойстик находится в
      6   ▼   4     нейтральном положении, функция возвращает значение 0).
          5

   Говорят, что  функция  STICK(0) "читает" клавиши  управления  курсором,
функция  STICK(1) "читает джойстик"  в первом  разъеме,  функция  STICK(2)
"читает джойстик"во втором разъеме.
   Приведем возможные значения функции STICK(0):
                         ▲                                              ▲
X=1, если нажата клавиша │; X=2, если нажаты одновременно клавиши ──▶ и │;
X=3, если нажата клавиша ──▶;X=4,если нажаты одновременно клавиши ──▶ и │;
X=5, если нажата клавиша │;                                             ▼
                         ▼
X=6, если нажаты одновременно клавиши ◀── и │; X=7,если нажата клавиша◀──;
                                      ▲     ▼
X=8, если нажаты одновременно клавиши │ и ◀──;
X=0, если не нажата ни одна из этих клавиш.

   Например, если Вы запустите программу
                 10 D=STICK(0):LOCATE 18,11:PRINT D:GOTO 10
и будете нажимать клавиши управления курсором, то  будете получать  значе-
ния переменной D от 0 до 8.
   Если же у Вас есть джойстик, установите его  в  порт джойстика номер 1
(он находится на правой боковой панели компьютера), замените  в строке 10
оператор  D=STICK(0)  на оператор  D=STICK(1) и вновь запустите программу
(итог будет аналогичным).

   Функция STRIG() определяет, нажата или нет нужная Вам  к н о п к а .
   Формат функции STRIG() следующий:
                             ┌─────────────┐
                             │   STRIG(β)  │
                             └─────────────┘
где:  STRIG("Stick TRIGer"-"кнопка джойстика")- служебное слово:
      β - арифметическое выражение,  целая часть которого  принадлежит от-
резку [0,4] и указывает на соответствующую кнопку джойстика.
   Функции  STRIG(1) и  STRIG(2) читают состояние кнопок джойстиков из ос-
новного комплекта MSX. Функции STRIG(3) и STRIG(4) читают состояние допол-
нительных кнопок джойстиков 1 и 2, причем:
   1) функция STRIG(0) читает состояние клавиши "пробел";
   2) функция STRIG(1) читает состояние кнопки 1 джойстика в разъеме 1;
   3) функция STRIG(2) читает состояние кнопки 1 джойстика в разъеме 2;
   4) функция STRIG(3) читает состояние кнопки 2 джойстика в разъеме 1;
   5) функция STRIG(4) читает состояние кнопки 2 джойстика в разъеме 2.
   Функция STRIG()  возвращает значение либо ноль, если  кнопка не нажата,
либо -1 , если кнопка нажата.

   П р и м е р  1.           IF STRIG(0) THEN BEEP
   ──────────────  Оператор вызывает звуковой сигнал (BEEP),  если кнопка
джойстика нажата (т.е. STRIG(0) имеет значение -1).
   При использовании этой функции, например, в процессе компьютерной игры,
когда требуется "вести стрельбу", функция STRIG(0) ежесекундно  задейству-
ется много раз. Для этих частых проверок значений существует  специальный
термин  "о п р о с".
   Метод опроса иллюстрируется примером 2. Программа начинается с вопроса
пользователю о том, располагает ли он джойстиком или работает за клавиату-
рой. Далее запрашиваются состояния пусковых кнопок,  и  в зависимости  от
того, какая из них нажата, выбирается джойстик.

   П р и м е р  2 [76].
   ───────────────────
   40 CLS:WIDTH 40
   60 PRINT "Нажмите пусковую кнопку":PRINT "выбранного джойстика или"
   80 PRINT "клавишу ПРОБЕЛ - для клавиатуры"
   90 PRINT:PRINT:PRINT "Нажимайте":PRINT:PRINT
   150 F=-1
   160 FOR I=0 TO 4:IF STRIG(I) THEN F=I:NEXT I
   190 IF F=-1 THEN GOTO 160
   200 BEEP
   240 IF F=0 THEN PRINT "Клавиатура ";
   250 IF F=1 OR F=3 THEN PRINT "Джойстик А";
   260 IF F=2 OR F=4 THEN PRINT "Джойстик B";
   270 PRINT " в действии":END

    В ожидании нажатия клавиши "пробел" опрос будет выполняться постоянно,
что делает возможной  н е м е д л е н н у ю  реакцию  программы. Напомним
Вам, что нажатие клавиши "пробел" может также проверяться с помощью  функ-
ции INKEY$, но в этом случае компьютер будет проверять текущее  состояние
буфера клавиатуры.
   З а м е ч а н и е. Функция STRIG(0) возвращает (-1) только,  если  кла-
виша "пробел" нажата во время  в ы ч и с л е н и я  значения этой функции.

   П р и м е р  3.   10 FOR I=0 TO 500:PRINT I:NEXT
   ──────────────    20 IF STRIG(0) THEN 10 ELSE 20
   Обратите внимание, что если клавиша "пробел" нажата во время вывода ин-
формации на экран, это событие не будет зафиксировано функцией  STRIG(0),
как произошло бы в случае замены программной строки 20 на строку
                     20 IF INKEY$=CHR$(32) THEN 10 ELSE 20
   При применении функции STRIG(0) компьютер "реагирует" на нажатие клави-
ши "пробел" т о л ь к о  при выполнении 20 строки. Функция STRIG(0) не пе-
рехватывает предварительного нажатия клавиши  "пробел", тогда как функция
INKEY$ реагирует на  в с е  предварительные нажатия. Сколько раз была  на-
жата клавиша "пробел", столько раз и выполнится соответствующая команда.

   П р и м е р  4. Ввод рисунков с клавиатуры при помощи "рукоятки"  (кла-
   ──────────────  виши управления курсором) и "кнопки" (клавиша "пробел")
встроенного "джойстика" с номером 0.
   α) 10 CLS:X=16:Y=11
      30 D=STICK(0)
      40 IF D=1 OR D=2 OR D=8 THEN Y=Y-1
      50 IF D=4 OR D=5 OR D=6 THEN Y=Y+1
      60 IF D=2 OR D=3 OR D=4 THEN X=X+1
      70 IF D=6 OR D=7 OR D=8 THEN X=X-1
      80 IF X<0 THEN X=0 ELSE IF X>36 THEN X=36
      90 IF Y<0 THEN Y=0 ELSE IF Y>20 THEN Y=20
      95 LOCATE X,Y
      100 IF STRIG(0) THEN PRINT "∗":GOTO 30 ELSE PRINT "+":GOTO 30

   А теперь исправьте "∗" на " ". Что изменилось в работе программы?

   β) 10 COLOR 1,15:SCREEN 2
      20 GOSUB 60:LINE (X,Y)-(X+10,Y+10)
      30 X1=X:Y1=Y:A$=INKEY$:IF A$="n" OR A$="N" THEN ELSE 20
      40 GOSUB 60:LINE (X1,Y1)-(X1+10,Y1+10),15:LINE (X,Y)-(X+10,Y+10)
      50 X1=X:Y1=Y:A$=INKEY$:IF A$="r" OR A$="R" THEN 20 ELSE 40
      60 D=STICK(0)
      70 IF D=1 OR D=2 OR D=8 THEN Y=Y-1
      80 IF D=4 OR D=5 OR D=6 THEN Y=Y+1
      90 IF D=2 OR D=3 OR D=4 THEN X=X+1
      100 IF D=6 OR D=7 OR D=8 THEN X=X-1
      110 RETURN'──▶

   П р и м е р  5.  А теперь настала очередь "настоящего" джойстика! 
   ──────────────
   α) 10 CLS:X=16:Y=11
      30 D=STICK(1)
      40 IF D=1 OR D=2 OR D=8 THEN Y=Y-1
      50 IF D=4 OR D=5 OR D=6 THEN Y=Y+1
      60 IF D=2 OR D=3 OR D=4 THEN X=X+1
      70 IF D=6 OR D=7 OR D=8 THEN X=X-1
      80 IF X<0 THEN X=0 ELSE IF X>36 THEN X=36
      90 IF Y<0 THEN Y=0 ELSE IF Y>20 THEN Y=20
      95 LOCATE X,Y
      100 IF STRIG(1) THEN PRINT "∗":GOTO 30 ELSE PRINT "+":GOTO 30

   β) 10 COLOR 1,15:SCREEN 2
      20 GOSUB 60:LINE (X,Y)-(X+10,Y+10)
      30 X1=X:Y1=Y:A$=INKEY$:IF A$="n" OR A$="N" THEN ELSE 20
      40 GOSUB 60:LINE (X1,Y1)-(X1+10,Y1+10),15:LINE (X,Y)-(X+10,Y+10)
      50 X1=X:Y1=Y:A$=INKEY$:IF A$="r" OR A$="R" THEN 20 ELSE 40
      60 D=STICK(2)
      70 IF D=1 OR D=2 OR D=8 THEN Y=Y-1
      80 IF D=4 OR D=5 OR D=6 THEN Y=Y+1
      90 IF D=2 OR D=3 OR D=4 THEN X=X+1
      100 IF D=6 OR D=7 OR D=8 THEN X=X-1
      110 RETURN'──▶

   З а м е ч а н и е.
   С помощью регистров Программируемого Звукового Генератора (PSG)  можно
определить состояние джойстиков (состояние клавиш  управления  курсором с
помощью регистров PSG определить нельзя!) и изменять состояние индикатора
"РУС". 
   Для Вас, конечно же, будет неожиданным сообщение о том, что  PSG имеет
16 регистров, причем регистры с номерами 0÷13 отвечают за генерацию звука,
а регистры 14 и 15 - за состояние джойстиков и индикатора "РУС".
   Для того, чтобы определить состояние джойстиков нужно в регистр с номе-
ром 15 занести следующие значения:

     Д л я  д ж о й с т и к а  1        Д л я   д ж о й с т и к а  2
  ┌───┬───┬───┬───┬───┬───┬───┬───┐  ┌───┬───┬───┬───┬───┬───┬───┬───┐
  │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │  │ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │
  ├───┼───┼───┼───┼───┼───┼───┼───┤  ├───┼───┼───┼───┼───┼───┼───┼───┤
  │ - │ 0 │ - │ 0 │ - │ - │ 1 │ 1 │  │ - │ 1 │ 0 │ - │ 1 │ 1 │ - │ - │
  └───┴───┴───┴───┴───┴───┴───┴───┘  └───┴───┴───┴───┴───┴───┴───┴───┘

  ...и прочитать регистр PSG с номером 14. Четыре его младших бита покажут
состояние выбранного с помощью регистра 15 джойстика:

                  ┌───┬───┬───┬───┬────┬────┬───┬───┐
                  │ 7 │ 6 │ 5 │ 4 │  3 │  2 │ 1 │ 0 │
                  ├───┤───┼───┼───┼────┼────┼───┼───┤
                  │ - │ - │ - │ - │ ─▶ │ ◀─ │ │ │ ▲ │
                  │   │   │   │   │    │    │ ▼ │ │ │
                  └───┴───┴───┴───┴────┴────┴───┴───┘

   Если бит в данной позиции "сброшен",то джойстик направлен в показанном
на таблице направлении.

   П р и м е р 6.  Автор программы: Г.Беленький. 26.05.90. 
   ─────────────
   10 DATA 3E,0F     :' LD   A,0Fh      ; В 15-й регистр PSG поместим
   20 DАТА 1Е,03     :' LD   Е,03h      ; 3 (для джойстика 1)
   30 DATA CD,93,00  :' CALL 0093h      ; BIOS записи (оператор SOUND не
   35 '                                 ; действует!)
   40 DATA 3E,0E     :' LD   A,0Eh      ; Читаем содержимое регистра 14
   50 DATA CD,96,00  :' CALL 0096h      ; BIOS чтения
   60 DATA 32,00,E0  :' LD   (E000h),A  ; Полученное число поместим в
   65 '                                 ; ячейку с адресом &HE000
   70 DATA C9        :' RET
   80 FOR I=0 TO 15:READ A$:POKE &HD000+I,VAL("&H"+A$):NEXT I
   90 DEFUSR=&HD000
   100 A=USR(0)                         ' Прочитаем состояние джойстика 1
   110 PRINT RIGHT$("0"+BIN$(NOT(PEEK(&HE000) AND 15)),4)

   П р и м е р 7.  Автор программы: Г.Беленький. 26.05.90. 
   ─────────────
   10 DATA 3E,0F      :' LD   A,0Fh        ; Подпрограмма, позволяющая
   20 DATA 1E,83      :' ld   E,83h        ; прочитать содержимое
   30 DATA CD,93,00   :' CALL 0093h        ; регистра PSG с номером 14,
   40 DATA 3E,0E      :' LD   A,0Eh        ; для определения
   50 DATA CD,96,00   :' CALL 0096h        ; состояния джойстика 1.
   60 DATA 32,00,E0   :' LD   (E000h),A    ;
   70 DATA C9         :' RET
   80 FOR I=0 TO 15:READ A$:POKE &HD000+I,VAL("&h"+A$):NEXT I
   90 DEFUSR=&HD000
   100 SCREEN 2,0
   110 SPRITE$(0)="ЧЧЧЧЧЧЧЧ"               ' Образ спрайта
   120 X=128:Y=96                          ' Начальные координаты спрайта
   140 PUT SPRITE 0,(X,Y),15,0
   150 A=USR(0)                            ' Определяем состояние
   160 A=PEEK(&HE000) AND 15               ' джойстика 1
   170 IF A=10 OR A=14 OR A=6 THEN Y=Y-2   ' Изменение координат
   180 IF A=9  OR A=13 OR A=5 THEN Y=Y+2
   190 IF A=10 OR A=11 OR A=9 THEN X=X-2
   200 IF A=6  OR A=7  OR A=5 THEN X=X+2
   210 GOTO 140

   Для того, чтобы изменить состояние индикатора "РУС", нужно в  регистре
PSG с номером 15 изменить старший бит.Если этот бит равен 0, то индикатор
включается, а если 1, то выключается.

   П р и м е р 8.  Автор программы: Г.Беленький. 26.05.90. 
   ─────────────
   10 DATA 3E,0F     :' LD   A,0Fh
   20 DATA 1E,00     :' LD   E,00h
   30 DATA CD,93,00  :' CALL 0093h
   40 DATA C9        :' RET
   50 FOR I=0 TO 7:READ A$:POKE &HD000+I,VAL("&H"+A$):NEXT I
   60 DEFUSR=&HD000
   70 A=USR(0)                 ' Включем индикатор "РУС"
   80 FOR I=0 TO 50:NEXT I
   90 POKE &HD003,128:A=USR(0) ' Выключем индикатор "РУС"
   100 FOR I=0 TO 50:NEXT I 
   110 POKE &HD003,0:GOTO 70

