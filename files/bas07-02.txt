   Кроме только что рассмотренных функций STICK и STRIG,для работы с джой-
стиком можно использовать функции PDL и PAD.
   Формат функции PDL следующий:
                                  ┌────────┐
                                  │ PDL(N) │  ,
                                  └────────┘
где:  PDL - служебное слово;
      N - арифметическое выражение,  целая  часть  которого должна принад-
лежать отрезку [1,12]  (в противном случае последует  сообщение об ошибке
                          "Illegal function call" .
   Функция PDL(N) возвращает значение кода положения и г р о в о г о  р ы-
ч а ж к а, подключенного к разъему для джойстика. Для  четных  значений N
считывается значение в разъеме 1, для нечетных - в разъеме 2.
   Если же у Вас нет игрового рычажка, но есть  д ж о й с т и к , не огор-
чайтесь и читайте дальше!
   Функция PDL(1) проверяет,происходило ли перемещение  в п е р е д  руко-
ятки джойстика в разъеме 1, и возвращает 255 ("истина"), если рукоятка не
перемещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(2) проверяет, происходило ли перемещение  в п е р е д руко-
ятки джойстика в разъеме 2, и возвращает 255 ("истина"), если рукоятка не
перемещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(3) проверяет,происходило ли перемещение  н а з а д  рукоят-
ки джойстика в разъеме 1, и  возвращает  255 ("истина"), если рукоятка не
перемещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(4) проверяет,происходило ли перемещение  н а з а д  рукоят-
ки джойстика в разъеме 2 и возвращает 255 ("истина"), если рукоятка не пе-
ремещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(5) проверяет,происходило ли перемещение  в л е в о  рукоят-
ки джойстика в разъеме 1 и возвращает 255 ("истина"), если рукоятка не пе-
ремещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(6) проверяет,происходило ли перемещение  в л е в о  рукоят-
ки джойстика в разъеме 2 и возвращает 255 ("истина"), если рукоятка не пе-
ремещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(7) проверяет,происходило ли перемещение  в п р а в о  руко-
ятки джойстика в разъеме 1 и возвращает 255 ("истина"),  если рукоятка не
перемещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(8) проверяет,происходило ли перемещение  в п р а в о  руко-
ятки джойстика в разъеме 2 и возвращает 255 ("истина"),  если рукоятка не
перемещалась, или 0 ("ложь") - в противном случае.
   Функция PDL(9) проверяет, нажата ли кнопка 1  джойстика в разъеме 1  и
возвращает 255 ("истина"), если кнопка не нажата, или 0 ("ложь") -  в про-
тивном случае.
   Функция PDL(10) проверяет, нажата ли кнопка 1 джойстика в разъеме 2  и
возвращает 255 ("истина"), если кнопка не нажата, или 0 ("ложь") -  в про-
тивном случае.
   Функция PDL(11) проверяет, нажата ли кнопка 2 джойстика в разъеме 1  и
возвращает 255 ("истина"), если кнопка не нажата, или 0 ("ложь") -  в про-
тивном случае.
   Функция PDL(12) проверяет, нажата ли кнопка 2 джойстика в разъеме 2  и
возвращает 255 ("истина"), если кнопка не нажата, или 0 ("ложь") -  в про-
тивном случае.

   Основное назначение функции PAD - работа с графическим планшетом.
   Формат функции PAD следующий:
                                ┌─────────┐
                                │  PAD(N) │ ,
                                └─────────┘
где:  PAD ("pad"-"графический планшет") - служебное слово;
      N  - арифметическое выражение,  целая часть которого должна  принад-
лежать отрезку [0,7] (в противном случае последует сообщение об ошибке
                         "Illegal function call" .
   Функция PAD(N) считывает данные с графического планшета, подключенного
к разъему для джойстика. Значение разъема 1 считываются при N, равном 1,2
или 3 , а с разъема 2 при N, равном 4,5,6 или 7.

   Смысл возвращаемой величины для каждого значения N:
   0 или 4 : возвращается 0 или -1 в зависимости от того, есть прикоснове-
ние пера к планшету или нет;
   1 или 5 : возвращается координата X точки касания;
   2 или 6 : возвращается координата Y точки касания;
   3 или 7 : возвращается состояние кнопки-переключателя (-1, если кнопка
нажата, иначе 0).
   Однако функцию PAD() можно применять и в том случае, если  у  Вас  нет
графического планшета, но есть  д ж о й с т и к.
   Функция PAD(0) проверяет, происходило ли  перемещение  в п е р е д  ру-
коятки джойстика в разъеме 1 и возвращает 0 ("ложь"), если рукоятка не пе-
ремещалась, или -1 ("истина") - в противном случае.
   Функция PAD(3) проверяет, происходило ли  перемещение  в п р а в о  ру-
коятки джойстика в разъеме 1 и возвращает 0 ("ложь"), если рукоятка не пе-
ремещалась, или -1 ("истина") - в противном случае.
   Функция PAD(4) проверяет, происходило ли  перемещение  в п е р е д  ру-
коятки джойстика в разъеме 2 и возвращает 0 ("ложь"), если рукоятка не пе-
ремещалась, или -1 ("истина") - в противном случае.
   Функция PAD(7) проверяет, происходило ли  перемещение  в п р а в о  ру-
коятки джойстика в разъеме 2 и возвращает 0 ("ложь"), если рукоятка не пе-
ремещалась, или -1 ("истина") - в противном случае.
   Функции PAD(1), PAD(2), PAD(5) и PAD(6) всегда возвращают значение 255.



   VII.2.  П е р е х о д  к  п о д п р о г р а м м е  п о  с о б ы т и ю


   Переход к подпрограмме  по  событию  ( п р е р ы в а н и е  в  програм-
ме пользователя) представляет собой особый тип условного перехода.
   Для выполнения "о б ы ч н о г о" условного перехода где-то в программе
располагается оператор, проверяющий истинность условия и передающий управ-
ление на указанный номер строки в соответствии  с  результатами  проверки.
Переход происходит только в том случае,если при выполнении программы в по-
следовательности операторов был  о б н а р у ж е н  оператор перехода.
   Что же касается перехода к подпрограмме по  с о б ы т и ю , то  компью-
тер непрерывно "проверяет" условие его возникновения в то время, как  про-
грамма пользователя выполняет другую работу.
   Обработка прерываний при наступлении события выполняется с помощью опе-
раторов двух типов:
        ┌──────────────────────────────────────────────────────┐
        │   ON  с о б ы т и е  GOSUB  н о м е р  с т р о к и   │    (1)
        └──────────────────────────────────────────────────────┘
   Этот оператор определяет событие, вызывающее проверку, а также место в
программе, куда будет передано управление при наступлении события.
                    ┌────────────────────────────────┐
                    │   с о б ы т и е  ON/OFF/STOP   │              (2)
                    └────────────────────────────────┘
   Если событие  в к л ю ч е н о  (ON) , то происходит переход, определен-
ный оператором (1). Разумеется, что этот оператор должен быть  предварите-
льно выполнен.
   Если событие  в ы к л ю ч е н о  (OFF) (по умолчанию), то перехода  на
подпрограмму обработки не происходит.
   Если событие  о с т а н о в л е н о  (STOP), то переход  при  наступле-
нии события не происходит, но информация о том, что событие произошло, за-
поминается, а переход происходит только после обнаружения в программе опе-
ратора                       с о б ы т и е  ON .
   Отметим, что операторы (1) или (2) не выполняют "сами по себе" переход
на подпрограмму обработки события.
   Когда выполнен оператор типа (1),относящийся к указанному событию, ком-
пьютер начинает проверять,не произошло ли данное событие во время выполне-
ния программы.
   Если событие произошло,текущий оператор все равно выполняется до конца.
Затем компьютер проверяет, выполнен ли оператор типа (2).
   Возможны  т р и  варианта:
   α) оператор           с о б ы т и е  ON/OFF/STOP
не был выполнен. Программа выполняется, как если бы событие не произошло; 
   β) оператор               с о б ы т и е  ON
был выполнен и является последним  оператором  этого  типа, относящимся к
данному событию. Происходит переход к подпрограмме, указанной в операторе
             ON  с о б ы т и е  GOSUB  н о м е р  с т р о к и
При входе в эту подпрограмму неявно выполняется оператор
                           с о б ы т и е  STOP
При выполнении оператора RETURN автоматически выполняется оператор
                           с о б ы т и е  ON  ,
и управление передается оператору, следующему за тем, при выполнении кото-
рого было обнаружено наступление события;
   γ) был выполнен оператор   с о б ы т и е  STOP  ,
и он является последним оператором обработки  данного  события. Программа
продолжает выполняться так, как будто бы событиe не произошло.Это событие
запоминается, и если в дальнейшем в программе встречается оператор
                             с о б ы т и е  ON   ,
относящийся к тому же событию, то происходит переход к подпрограмме  обра-
ботки события.

   Имеется возможность организовать переход  на  подпрограммы  по соверше-
нию таких событий, как истечение определенного интервала времени, нажатие
какой-либо клавиши F1÷F10, нажатие клавиш "CTRL"+"STOP" и т.п. Об этом  и
пойдет речь в следующих разделах.
┌────────────────────────────────────────────────────────────────────────┐
│   Перед тем, как выполнить программу, содержащую переход  к подпрограм-│
│мам по событию,не забудьте (если работаете на компьютере MSX-2) набрать │
│                             CALL NETEND                                │
└────────────────────────────────────────────────────────────────────────┘



                VII.2.1.   П е р е х о д  п о  к л ю ч у 


                                 Стоять я не могу... Мои колени слабеют...
                                 душно... Где ключи? Ключи, ключи мои...
                                                              А.С. Пушкин


   MSX-BASIC включает в себя средство, позволяющее  использовать  функцио-
нальные клавиши не только для ввода некоторого слова, но и для прерывания
выполнения программы и вызова определенной подпрограммы.
                     ┌────────────────────────────────┐
   Оператор          │    ON KEY GOSUB n1,n2,...,nk   │ ,
                     └────────────────────────────────┘
где:  ON ("по"), KEY ("ключ","клавиша"), GOSUB - служебные слова;
       n1,n2,...,nk - номера строк программы (1≤k≤10);
осуществляет передачи управления подпрограммам, расположенным со строк n1,
n2,...,nk, причем нажатие функциональной клавиши  Fk (k=1,2,...,10) приво-
дит к передаче управления подпрограмме, начинающейся со строки  с номером
nk (k=1,2,...,10). Если Вы хотите использовать только некоторые функциона-
льные клавиши, то пропустите ненужные номера строк (оставив запятые!). 
   Предварительно функциональную клавишу  Fk  необходимо "активизировать"
оператором                 ┌──────────────────┐
                           │     KEY(k)ON     │ .
                           └──────────────────┘
   Записанное в скобках значение k определяет,какая именно функциональная
клавиша будет "активизирована". После выполнения приведенного выше  опера-
тора нажатие клавиши Fk не будет приводить к генерации какой-либо  строки
символов.
   Теперь перед выполнением каждого нового оператора программы интерпрета-
тор будет проверять,не была ли нажата какая-нибудь "активизированная" фун-
кциональная клавиша, и если такое нажатие произошло, то интерпретатор  вы-
зывает соответствующую подпрограмму.
   Для блокирования (запрещения) такого вызова необходимо выполнить опера-
тор                        ┌──────────────────┐
                           │     KEY(k)OFF    │ .
                           └──────────────────┘
   Как и в предыдущих случаях, значение в скобках k определяет номер функ-
циональной клавиши, для которой выполняется данный оператор.
   Иногда возникает необходимость временно оградить программу  от прерыва-
ний, вызываемых функциональными клавишами, и в то же время запомнить  каж-
дое нажатие такой клавиши с тем, чтобы впоследствии можно было  выполнить
все соответствующие вызовы подпрограммы. Это достигается с помощью  опера-
тора                       ┌──────────────────┐
                           │    KEY(k)STOP    │ ,
                           └──────────────────┘
который временно "дезактивизирует" функциональную клавишу Fk .
   Если после выполнения указанного выше оператора производились  нажатия
функциональной клавиши Fk, то все соответствующие вызовы подпрограмм  все-
таки будут реализованы, но не сразу, а только после выполнения  оператора
                               KEY(k)ON   ,
вновь "активизирующего" эту клавишу.

   П р и м е р ы.
   ─────────────
   α) 10 ON KEY GOSUB 100             β) 10 ON KEY GOSUB 100
      20 KEY(1)ON:SCREEN 2               20 KEY(1)ON:SCREEN 2
      30 LINE(50,50)-(200,150),,B        30 LINE(50,50)-(200,150),,B
      40 GOTO 30                         40 GOTO 30
      100 ' Подпрограмма                 100 ' Подпрограмма
      105 :::                            105 KEY(1)ON
      110 BEEP:CLS                       110 BEEP:CLS
      120 FOR I=10 TO 90 STEP 10         120 FOR I=10 TO 90 STEP 10
      130 CIRCLE(120,100),I:NEXT I       130 CIRCLE(120,100),I:NEXT I
      140 CLS:RETURN 30                  140 CLS:RETURN 30

   γ) Наберите пример β), вставив строку:
                    135 IF I=50 THEN KEY(1)STOP  .

   Оператор  ON KEY GOSUB позволяет легко организовывать "листание" закон-
ченных  программных  фрагментов во время  выполнения  программы, например,
страницы   справочной  информации  1÷3  вызываются  нажатием  на  клавиши
"F1"÷"F3", демонстрационный  пример выполняется при нажатии клавиши  "F4",
выход из программы - при нажатии клавиши "F5" и т.д.



  VII.2.2.    П е р е х о д  п о  в р е м е н н о м у  и н т е р в а л у


                       ┌────────────────────────────┐
   Оператор            │    ON INTERVAL=α GOSUB n   │ ,
                       └────────────────────────────┘
где:  ON , INTERVAL ("интервал"), GOSUB- служебные слова;
      α - арифметическое выражение, целая часть значения которого  принад-
лежит отрезку [1,65535];
      n - номер программной сроки,
назначает интервалы времени, равные
                              INT(α)/60  секунд,
через которые компьютер периодически передает управление подпрограмме,рас-
положенной с программной строки с номером n. Отсчет временных  интервалов
реализуется специальным счетчиком, принимающим значения
             1,2,...,INT(α), 1,2,...,INT(α), 1,2,...,INT(α),...
   По аналогии с пунктом VII.2.1 счетчик "активизируется" оператором
                          ┌─────────────────────┐
                          │     INTERVAL ON     │ ,
                          └─────────────────────┘
"дезактивизируется" оператором
                          ┌─────────────────────┐
                          │     INTERVAL OFF    │ ,
                          └─────────────────────┘
и временно "дезактивизируется" оператором
                          ┌─────────────────────┐
                          │    INTERVAL STOP    │ .
                          └─────────────────────┘
   П р и м е ч а н и е. Прежде чем запустить  составленную Вами программу,
убедитесь в том, что интервал  INT(α)/60  не короче, чем время выполнения
подпрограммы обработки, иначе она будет бесконечно вызывать саму себя,ибо
в конце ее неявно выполняется оператор INTERVAL ON.

   П р и м е р  1. Проследите за выполнением следующего фрагмента при K=1,
   ──────────────  2,6.
   10 INPUT K:ON INTERVAL=K*60 GOSUB 80
   30 INTERVAL ON:GOSUB 100:INTERVAL STOP:GOSUB 100
   50 INTERVAL ON:GOSUB 100:INTERVAL OFF:GOSUB 100
   70 END
   80 PRINT "Проверка":RETURN
   100 FOR K=1 TO 7000:NEXT:RETURN

   П р и м е р  2.  "Секундомер"!
   ──────────────
   5 INPUT "Сколько секунд отсчитать";K:ON INTERVAL=60 GOSUB 80:S=1:PRINТ
   0;TAB(4)"мин"0TAB(11)"сек":LOCATE POS(0),CSRLIN-1
   10 INTERVAL ON:FOR I=1 TO K*1000/2.395:NEXT:LOCATE POS(0),CSRLIN+1:END
   80 PRINT M;TAB(4) "мин";S;TAB(11) "сек":LOCATE POS(0),CSRLIN -1:S=S+1:
   IF S MOD 60=0 THEN J=0:LOCATE POS(0),CSRLIN:M=M+1:S=0
   90 RETURN

   Обработка интервала оказывается очень удобной в игровых программах,где
нужно повторять какое-либо действие через одинаковые интервалы времени. 

   П р и м е р  3[76]. Данная программа позволяет наряду с вводом  текста
   ──────────────────  организовать отсчет времени ("часы") в правом верх-
нем углу экрана. Заметим,что "опрос" клавиатуры выполняется с помощью фун-
кции INKEY$. В этом случае функция INPUT$() неприменима,так как она ожида-
ет нажатия клавиши, поэтому ввод с клавиатуры будет мешать нормальному из-
менению состояния счетчика времени.
   40 CLS:WIDTH 40:ON INTERVAL=50 GOSUB 230
   60 TIME=0:INTERVAL ON
   80 LOCATE 16,0,0:PRINT"Время:":LOCATE 24,0:PRINT H;":";M;":";S
   100 INTERVAL ON
   110 A$=INKEY$:IF A$=""THEN GOTO 110 ELSE PRINT A$;
   140 'Очистка заполненного экрана
   160 IF CSRLIN=23 AND POS(0)=37 THEN PRINT A$:CLS:LOCATE 0,1,0:GOTO 80
   170 GOTO 110
   190 'Подпрограмма обработки прерывания
   230 X=POS(0):Y=CSRLIN 'Запоминание координат курсора
   240 S=S+1
   250 IF S=60 THEN M=M+1:S=0
   260 IF M=60 THEN H=H-1:M=0
   270 IF H=24 THEN H=0:LOCATE 24,0,0:PRINT
   280 LOCATE 24,0,0:PRINT H;":";M;":";S:LOCATE X,Y,1:RETURN



  VII.2.3.   П е р е х о д  по  н а ж а т и ю  к л а в и ш  "CTRL"+"STOP"


                          ┌──────────────────────┐
   По оператору           │    ON STOP GOSUB n   │ ,
                          └──────────────────────┘
где:   ON , STOP, GOSUB - служебные слова;
       n - номер программной строки;
при нажатии на клавиши  "CTRL"+"STOP" может осуществиться передача  управ-
ления подпрограмме, расположенной со строки n.
   При этом действие "CTRL"+"STOP" должно быть  подтверждено (ON), отмене-
но (OFF) или приостановлено (STOP) соответственно операторами:
                     ┌─────────────────────────────────┐
                     │   STOP ON, STOP OFF, STOP STOP  │
                     └─────────────────────────────────┘
   П р и м е р.
   ───────────
   10 CLS:STOP ON:ON STOP GOSUB 80
   20 PRINT"Нажмите клавишу RESET !!!":GOTO 20
   80 PRINT"Вам уже ничего не поможет! Делайте, как подсказывают."
   90 RETURN

   На закуску отметим интересный факт:

   10 STOP ON:ON STOP GOSUB 50:FOR I=1 TO 5000:NEXT:END
   50 POKE &HFBB0,1:RETURN '──▶

   Нажатие клавиш "CTRL"+"STOP" игнорируется. "Доступ" к тексту программы
становится возможным, если одновременно нажать пять клавиш:
                      "CTRL"+"GRAPH"+"SHIFT"+"1"+"3"  или
четыре клавиши        "CTRL"+"GRAPH"+"РУС"+"SHIFT"    !
   Если же оператор POKE &HFBB0,1 заменить на оператор POKE &HFBB0,0 , то
Вас уже ничто не спасет!
   Обратите внимание,что обрабатывается только одновременное нажатие двух
клавиш: "CTRL"+"STOP". Нажатие одной клавиши "STOP" просто "задержит" про-
грамму. Средствами языка MSX-BASIC нажатие клавиши STOP "перехватываться"
не может. Однако ее можно "отключить" во время выполнения функции INPUT$.
   Обработка нажатия клавиш "CTRL"+"STOP" позволит избежать любого  вмеша-
тельства в программу, выполняющуюся в Ваше отсутствие!



           VII.2.4.     П е р е х о д  п о  д ж о й с т и к у


   Поговорим теперь об операторе перехода к подпрограмме по нажатию  кноп-
ки джойстика:┌────────────────────────────────────────────┐
             │    ON STRIG GOSUB n[,n1][,n2][,n3][,n4]    │ ,
             └────────────────────────────────────────────┘
где:  ON, STRIG, GOSUB - служебные слова;
      n - номер первой строки подпрограммы,  которой передается   управле-
ние при нажатии клавиши "пробел" (кнопка "джойстика" с номером 0);
      n1 - номер первой строки подпрограммы,  которой передается  управле-
ние при нажатии кнопки 1 джойстика 1;
      n2 - номер первой строки подпрограммы,  которой передается  управле-
ние при нажатии кнопки 1 джойстика 2;
      n3 - номер первой строки подпрограммы,  которой передается  управле-
ние при нажатии кнопки 2 джойстика 1;
      n4 - номер первой строки подпрограммы,  которой передается  управле-
ние при нажатии кнопки 2 джойстика 2.

   Для того, чтобы переход к подпрограмме по джойстику был  возможен, его
можно подтвердить, отменить или приостановить  соответственно операторами
             ┌─────────────────────────────────────────────┐
             │   STRIG(k)ON , STRIG(k)OFF , STRIG(k)STOP   │ ,
             └─────────────────────────────────────────────┘
где  k - арифметическое выражение, целая часть значения которого определя-
ет номер кнопки джойстика, INT(k)∈[0,4] (k=0  соответствует  клавише "про-
бел").
   Оператор ON STRIG GOSUB приостанавливает нормальный ход выполнения про-
граммы и передает управление соответствующей подпрограмме, если нажата со-
ответствующая кнопка джойстика. Переход к первому номеру строки из списка
осуществляется в том случае, если нажата клавиша "пробел", ко второму- ес-
ли нажата кнопка 1 джойстика 1 и т.д.

   П р и м е р  1.
   ──────────────
   5 STRIG(0) ON:STRIG(1) ON:STRIG(3) ON
   7 ON STRIG GOSUB 100,200,,300
   10 FOR I=1 TO 2000:NEXT:END
   100 PRINT "Нажата клавиша 'ПРОБЕЛ'"    :END
   200 PRINT "Нажата кнопка 1 джойстика 1":END
   300 PRINT "Нажата кнопка 2 джойстика 1":END

   П р и м е р  2[76].  Моделирование работы простого реле времени.
   ──────────────────
   50 ON STRIG GOSUB 270
   60 CLS:R=RND(-TIME):PRINT "Реле времени"
   100 PRINT "Когда раздастся звонок, нажмите клавишу 'пробел'"
   130 T=INT(RND(1)*500)+10
   140 ON INTERVAL=T GOSUB 200
   150 INTERVAL ON
   160 GOTO 160
   190 'Подпрограмма отсчета времени
   200 INTERVAL OFF:BEEP:TIME=0:STRIG(0)ON
   230 GOTO 230
   260 'Анализ прерывания от джойстика
   270 STRIG(0) OFF
   280 PRINT "Ваша реакция":PRINT"=";TIME/60;"секунд":END

   Пока выполняется подпрограмма,всякий новый сигнал от кнопки  джойстика
откладывается до окончания текущей обработки.
   После возврата управления из подпрограммы интерпретатор определит нали-
чие ожидающих сигналов,после чего будет выполнен очередной переход на под-
программу обработки.
                          ┌────────────────────┐
   Оператор               │    STRIG (k) ON    │
                          └────────────────────┘
включает оператор ON STRIG GOSUB для соответствующего джойстика с номером
k, после чего перед выполнением каждого оператора интерпретатор проверяет,
нажата ли кнопка джойстика.
                           ┌──────────────────┐
   Оператор                │  STRIG (k) STOP  │
                           └──────────────────┘
приостанавливает разрешение обработки прерываний по нажатию  кнопки  джой-
стика, но сохраняет информацию о нажатии.

   П р и м е р  3.  Использование "встроенного" джойстика ! 
   ──────────────
   10 STRIG (0) ON:ON STRIG GOSUB 130:DEFINT A-Z
   20 DATA  3,7,15,15,31,31,31,31,15,0,49,1,1,0,0,0,192,240,248,252,180,1
   82,182,182,252,2,244,240,236,216,112,32 : '"Череп"
   30 DATA 16,56,56,56,16,16,16,16         : 'Вид оружия
   40 COLOR 15,1,1:SCREEN 2,2:X=125:Y=96
   50 FOR T=1 TO 32:READA:B$=B$+CHR$(A):NEXT:SPRITE$(1)=B$:FOR I=1 TO 8:R
   EAD W:C$=C$+CHR$(W):NEXT:SPRITE$(2)=C$   'Формирование спрайтов
   60 GOSUB 70:GOTO 60  'Основная программа.
   70 D=STICK(0):IF D=1 OR D=2 OR D=8 THEN Y=Y-3  'Движение  "черепа" при 
   80 IF D=2 OR D=3 OR D=4 THEN X=X+3           'помощи клавиш управления
   90 IF D=4 OR D=5 OR D=6 THEN Y=Y+3                  'курсором
   100 IF D=6 OR D=7 OR D=8 THEN X=X-3            
   110 IF Y<60 THEN Y=60 ELSE IF Y>145 THEN Y=145 ' Ограничение  движения
   120 PUT SPRITE 1,(X,Y):RETURN'──▶ 
   130 A=X:B=Y:C=A+8  'Подпрограмма полета стрелы
   140 B=B-16:PUT SPRITE 2,(A,B),8,2:PUT SPRITE 3,(C,B),8,2:GOSUB 70
   150 E=STRIG(0):IF B<10 THEN IF E=0 THEN RETURN ELSE 130 ELSE 140

   П р и м е р  4.  А теперь - использование "настоящего" джойстика ! 
   ──────────────
   10 STRIG (1) ON:ON STRIG GOSUB ,130:DEFINT A-Z
   20 DATA  3,7,15,15,31,31,31,31,15,0,49,1,1,0,0,0,192,240,248,252,180,1
   82,182,182,252,2,244,240,236,216,112,32 : '"Череп"
   30 DATA 16,56,56,56,16,16,16,16         : 'Вид оружия
   40 COLOR 15,1,1:SCREEN 2,2:X=125:Y=96
   50 FOR T=1 TO 32:READA:B$=B$+CHR$(A):NEXT:SPRITE$(1)=B$:FOR I=1 TO 8:R
   EAD W:C$=C$+CHR$(W):NEXT:SPRITE$(2)=C$   'Формирование спрайтов
   60 GOSUB 70:GOTO 60  'Основная программа.
   70 D=STICK(1):IF D=1 OR D=2 OR D=8 THEN Y=Y-3  'Движение  "черепа" при 
   80 IF D=2 OR D=3 OR D=4 THEN X=X+3           'помощи клавиш управления
   90 IF D=4 OR D=5 OR D=6 THEN Y=Y+3                  'курсором
   100 IF D=6 OR D=7 OR D=8 THEN X=X-3            
   110 IF Y<60 THEN Y=60 ELSE IF Y>145 THEN Y=145 ' Ограничение движения
   120 PUT SPRITE 1,(X,Y):RETURN'──▶ 
   130 A=X:B=Y:C=A+8  'Подпрограмма полета стрелы
   140 B=B-16:PUT SPRITE 2,(A,B),8,2:PUT SPRITE 3,(C,B),8,2:GOSUB 70
   150 E=STRIG(1):IF B<10 THEN IF E=0 THEN RETURN ELSE 130 ELSE 140



       VII.2.5.  О д н о в р е м е н н а я   о б р а б о т к а 
                  с о б ы т и й  р а з л и ч н ы х  т и п о в


   Обрадуем Вас: в одной программе допустима обработка нескольких событий
различных типов! Однако для того, чтобы структура программы оставалась яс-
ной, необходимо учитывать следующее:
   1) перед входом в подпрограмму обработки события всегда неявно выполня-
ется оператор                с о б ы т и е  STOP .
   Если в процессе выполнения этой подпрограммы происходит это же событие,
то подпрограмма по завершении будет сразу же  в ы з в а н а  снова. Чтобы
избежать этого, помещайте в начале подпрограммы оператор
                           с о б ы т и е  STOP или 
оператор                   с о б ы т и е  OFF                           .
   2) применение операторов
               с о б ы т и е  OFF    и   с о б ы т и е  STOP
"очищает" от обработки прерываний определенные участки Вашей программы;
   3) если событие остановлено (STOP),то факт возникновения этого события
запоминается. 
    ┌────────────────────────────────────────────────────────────────┐
    │  Если же событие того же типа возникает еще раз, то компьютер  │
    │         запоминает наступление только последнего события       │
    └────────────────────────────────────────────────────────────────┘
   4) приоритет (в порядке убывания) при одновременном возникновении собы-
тий: α) обработка ошибок в программе пользователя
     β) ON KEY GOSUB
     γ) ON STOP GOSUB
     δ) ON SPRITE GOSUB
     σ) ON STRIG GOSUB
     μ) ON INTERVAL GOSUB
     Φ) прерывания в локальной сети
     Γ) другие прерывания.
   В заключение запомните, что использование в Вашей программе  полдюжины
(≈шесть!) операторов перехода к подпрограммам по событию может  мгновенно
завести в тупик любого, пытающегося разобраться в ней программиста!

