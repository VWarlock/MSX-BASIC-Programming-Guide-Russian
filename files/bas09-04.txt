         IX.3.1.  О п е р а т о р ы   MAXFILES= , OPEN  и  CLOSE

   Перемещение логических строк последовательных файлов из оперативной па-
мяти на дискету и в обратном направлении производится  через  к о н т р о-
л ь н ы е  б у ф е р ы   ф а й л о в . Последние  объявляются  оператором
MAXFILES=. Максимальное количество файлов, которые могут быть  открыты од-
новременно, устанавливается оператором
                          ┌────────────────────┐
                          │     MAXFILES=A     │ ,
                          └────────────────────┘
где:  MAX, FILES - служебные слова;
      A - арифметическое выражение, целая часть значения которого  принад-
лежит отрезку [0,15]. 
   При включении компьютера значение параметра A равнo 1.Таким образом,ес-
ли Вы хотите открыть  т о л ь к о  о д и н  файл,то использование операто-
ра MAXFILES необязательно.
 ┌──────────────────────────────────────────────────────────────────────┐
 │  Файл #0 всегда открыт. MSX-Disk BASIC использует контрольный буфер  │
 │     этого файла для "своих нужд" (он используется  при выполнении    │
 │               операторов LOAD, SAVE, KILL, RUN, MERGE)               │
 └──────────────────────────────────────────────────────────────────────┘
   При работе с последовательными файлами буфера используются самым  прос-
тым способом: пересылаемые в файл данные накапливаются в буфере  файла, а
по заполнении буфера его содержимое сразу целиком переписывается  в диско-
вый файл;при этом буфер файла очищается для следующей порции выходных дан-
ных. При чтении файла соответствующие данные поступают из того же  самого
буфера, а не считываются непосредственно с поверхности дискеты.Как только
все необходимые данные считаны из буфера, средства MSX-BASIC обеспечивают
повторное его заполнение информацией из дискового файла.
   Учтите,что при использовании оператора MAXFILES= автоматически выполня-
ется оператор CLEAR, но если Вы используете в программе оба оператора, то
располагайте оператор MAXFILES=  вслед за оператором CLEAR.
   Вам, конечно же, ясно, что перед использованием файла  Вы  должны объя-
вить его  о т к р ы т ы м . Открытие файла осуществляется оператором OPEN,
в котором задается:
   α) имя устройства (A:,B:,MEM:,CAS:,CRT:,GRP:,LPT:,COM:);
   β) имя файла;
   γ) направление потока данных; 
   δ) номер, присвоенный файлу для передачи данных.
   Синтаксис оператора OPEN:
                  ┌───────────────────────────────────┐
                  │              { INPUT  }           │
                  │   OPEN B FOR { OUTPUT } AS[#]n    │ ,
                  │              { APPEND }           │
                  └───────────────────────────────────┘
где:  OPEN("открыть"), FOR("для"), INPUT("ввод"), OUTPUT("вывод"), APPEND
("присоединение") - служебные слова;
      В - строковое выражение, значение  которого задает имя устройства и
имя файла.
 ┌──────────────────────────────────────────────────────────────────────┐
 │   Сейчас мы познакомим Вас с именами  у с т р о й с т в:             │
 │   α) устройство CRT: отвечает за вывод информации на  т е к с т о -  │
 │ в ы й  экран ("CaRet"-"символ");                                     │
 │   β) устройство GRP: отвечает за вывод информации на экран  в  г р а-│
 │ ф и ч е с к и х  режимах ("GRaPhics"-"графика");                     │
 │   γ) устройство LPT: отвечает за вывод информации  на  п р и н т е р │
 │ ("Line PrinT"-"печать строки");                                      │
 │   δ) устройство COM: (только для компьютеров MSX-1) отвечает за  дви-│
 │ жение  информации  по  л о к а л ь н о й  сети ("COMmunication"- "пе-│
 │ редача данных");                                                     │
 │   Φ) устройство MEM: (только для MSX-2) - это не что иное, как  RAM- │
 │ диск ("MEMory"-"память");                                            │
 │   π) устройство CAS: является накопителем на магнитной ленте  (м а г-│
 │ н и т о ф о н о м) ("CASsette type"-"кассетная лента");              │
 └──────────────────────────────────────────────────────────────────────┘
     n - арифметическое выражение, целая часть  значения  которого принад-
лежит:
         α) отрезку [0,6]  для файлов на дискете,
         β) отрезку [0,15] для файлов на других устройствах,
и определяет номер контрольного буфера файла;
     # - необязательный символ.

   При выполнении  оператора OPEN файлу В "назначается" для  работы  конт-
рольный буфер файла с номером n.
 ┌──────────────────────────────────────────────────────────────────────┐
 │    Параметры  INPUT, OUTPUT и APPEND указывают направление последую- │
 │ щего движения информации относительно компьютера.                    │
 │    Оператор OPEN с параметром INPUT открывает файл д л я  в в о д а  │
 │ строк с дискеты в буфер. Чтение будет организовано от начала файла.  │
 │    Оператор OPEN с параметром OUTPUT открывает файл  д л я  в ы в о- │
 │ д а  строк с буфера на дискету. Запись будет осуществляться от нача- │
 │ ла файла. Оператор OPEN с параметром APPEND открывает файл для выво- │
 │ да строк с буфера на дискету,но запись будет производиться с  к о н- │
 │ ц а  файла.                                                          │
 │    Будьте осторожны: параметр APPEND не может использоваться при от- │
 │ крытии файлов на устройствах CAS:, CRT:, GRP:, LPT: и COM: !         │
 │    Параметр INPUT не может использоваться при открытии файлов на     │
 │ устройствах CRT:, GRP: и LPT:                                        │
 └──────────────────────────────────────────────────────────────────────┘
    ┌───────────────────────────┐          ┌───────────────────────┐
    │   К о н т р о л ь н ы й   ◀───INPUT──│                       │
    │         б у ф е р         │──OUTPUT──▶     Д и с к е т а     │
    │         ф а й л а         │──APPEND──▶                       │
    └───────────────────────────┘          └───────────────────────┘

   Оператор OPEN с параметром FOR OUTPUT создает новый дисковый файл с за-
данным именем. Если файл с таким именем уже есть,то он автоматически  уни-
чтожается и создается новый файл с тем же именем.
   Оператор OPEN...FOR APPEND обеспечивает поиск названного  файла  среди
уже существующих, с тем чтобы добавить новые записи в его конец, но  если
требуемого файла найти не удалось, то автоматически создается новый  файл
с заданным именем.
   Модификация оператора с параметром FOR INPUT реализует поиск данных  с
конкретным именем, отсутствие которого означает ошибку.

   П р и м е р ы:
   ─────────────
   α) OPEN"CAS:ADDRESS" FOR INPUT AS #1
       Устройство:  CAS:
       Файл:        ADDRESS
       Направление: INPUT (файл, сохраненный на ленте, нужно ввести)
       Номер файла: 1
   β) OPEN"ADDRESS" FOR OUTPUT AS #1
       Устройство:  A:  (по умолчанию в MSX-Disk BASIC)
       Файл:        ADDRESS
       Направление: OUTPUT (файл должен быть создан на дискете)
       Номер файла: 1
   γ) OPEN"B:ADDRESS" FOR APPEND AS #2
       Устройство:  B:
       Файл:        ADDRESS
       Направление: APPEND (добавление к уже существующему файлу)
       Номер файла: 2
   Можно открыть файл с последовательным доступом в режиме записи, исполь-
зуя один номер файла, и в режиме чтения, используя  другой. Однако, каждо-
му номеру файла будет при этом соответствовать  с в о й  б у ф е р, никак
не связанный с другими.
   Если же Вы используете только один буфер, то для изменения  режима  до-
ступа к файлу последний необходимо закрыть, а затем  вновь  открыть. Этот
прием особенно удобен, когда Вы хотите использовать  в программе  в любой
момент только один открытый файл (MAXFILES=1).
 ┌──────────────────────────────────────────────────────────────────────┐
 │  Однажды открытый, но не закрытый файл не может быть открыт повторно.│
 └──────────────────────────────────────────────────────────────────────┘
   В противном случае компьютер сообщает: "File already open".

   З а к р ы т и е  файла позволяет Вам использовать буфер с тем же  номе-
ром для открытия другого файла. Оператор, закрывающий файлы, выглядит так:
                  ┌───────────────────────────────────┐
                  │   CLOSE [[#]N1,[#]N2,...,[#]Nk]   │ ,
                  └───────────────────────────────────┘
где: CLOSE - служебное слово; 
     N1, N2,..., Nk - арифметические выражения, целые части  значений  ко-
торых определяют номера контрольных буферов файлов (FCB).Эти значения дол-
жны принадлежать отрезку [0,15].
   Оператор CLOSE без параметров закрывает  в с е  открытые ранее файлы.
   При записи данных оператор CLOSE обеспечивает вывод в файл,который был
открыт ранее в режиме "FOR OUTPUT", кода конца файла
                              EOF ("End Of File")
с кодом ASCII, равным &h1A.


          IX.3.2.  О п е р а т о р ы   PRINT# , PRINT#n,USING .
                       Ф у н к ц и и  LOF() и LOC() 


                             Да,- повторял он себе,- если бы на борту "Пи-
                             лигрима" я знал все, что должен знать настоя-
                             щий моряк, сколько  несчастий  можно было бы
                             избежать!
                                          Жюль Верн. Дети капитана Гранта


   Для формирования строк файла с последовательным доступом  используются
операторы  PRINT#  и  PRINT#USING.
   Оператор PRINT# записывается в таком виде:
                          ┌────────────────────────┐
                          │               {└─┘}    │
                          │    PRINT #n,S { ; }    │ ,
                          │               { , }    │
                          └────────────────────────┘
где: PRINT ("печатать", "вывести") - служебное слово;
     n  - арифметическое выражение, целая часть значения которого  опреде-
ляет номер контрольного буфера файла;
     S  - список арифметических и (или) строковых выражений:
                               γ1,γ2,...,γk ;
     └─┘ - обозначение символа пробел (" ").
   При выполнении оператора PRINT# значение выражения γi (i=1,2,...,k) по-
следовательно байт за байтом выводится в буфер почти так же, как это дела-
ется командой PRINT . Разница состоит лишь в трактовке  зонного  формата.
┌───────────────────────────────────────────────────────────────────────┐
│    Если между двумя выражениями в списке  S оператора PRINT# раздели- │
│ телем  является з а п я т а я ,то при выводе в буфер соответствующих  │
│ значений между ними помещается четырнадцать дополнительных пробелов.  │
│    Если последним символом в операторе  PRINT# является  п р о б е л, │
│ то выполнение оператора PRINT# приводит к формированию полной строки, │
│ но  вместе  с  м е т к о й  ее окончания. Иначе создается лишь часть  │
│ строки, а завершается ее формирование  или  последующими операторами  │
│ PRINT# , или закрытием файла.                                         │
└───────────────────────────────────────────────────────────────────────┘
   Длина строки вместе с концевой меткой не может превысить 256 байтов, а
данные выводятся на диск в формате ASCII и только тогда,  когда заполняет-
ся буфер или закрывается файл.
   Для экономного размещения данных на диске и избежания  ошибок  при  их
считывании целесообразно список S в операторе PRINT# записывать в виде:

                   γ1;",";γ2;","; ...;",";γк{└─┘}
                                            { ; }

   В этом случае значения в создаваемой строке располагаются  в  п л о т -
н о м  формате и отделяются друг от друга запятыми. 
   Будем считать, что информация в одном операторе  PRINT# составляет  от-
дельную логическую строку. Строка разбивается на  п о л я . Каждому  полю
логической строки соответствует переменная из списка S.
   Так логическая строка, состоящая из трех полей - фасон одежды S$, цвет  
одежды C$, цена одежды P - будет выведена в файл оператором

                   PRINT #1,S$;",";C$;",";P
                            ▲      ▲      ▲
                            │      │      │
          Переменные, определяющие поля данной логической строки

   Если значение какого-либо строкового выражения γi содержит символы ","
и (или) ";", то в качестве разделителей можно использовать символ ";", за-
даваемый строковой функцией CHR$(34):
                           CHR$(34) γs CHR$(34)

   П р и м е р  1 [7].  Запись данных в файл последовательного доступа.
   ─────────────────
   10 OPEN "GAMES" FOR OUTPUT AS #1
   20 FOR X=1 TO 5
   30    INPUT"Введите название игры";F$:PRINT #1,F$
   50 NEXT X
   60 CLOSE #1
   run
   Введите название игры? Футбол
   Введите название игры? Гольф
   Введите название игры? Баскетбол
   Введите название игры? Хоккей
   Введите название игры? Регби
   Ok

   Если файл с именем "GAMES" уже существовал, то данная программа сотрет
его старое содержимое и будет писать туда заново.
   Оператор PRINT# , не оканчивающийся символом "," или ";" автоматически
порождает печать символа ┌─────────────────────────────────┐
                         │ CHR$(13) (код клавиши "RETURN") │ .
                         └─────────────────────────────────┘
Этот символ попадает в буфер и в конце концов в файл, где он служит разде-
лителем между текущей записью и записью, следующей за ней.

   П р и м е р 2 [5].  Открывается новый или ранее созданный  файл  "Щука"
   ─────────────────   для вывода в него  строк  от  начала.  Программная
строка 50 позволяет сформировать в буфере одну строку.
   20 OPEN "Щука" FOR OUTPUT AS#1
   30 A=5:B$="трава":C=83.157
   50 PRINT #1,A;",";B$;",";C
   60 CLOSE #1

   П р и м е р 3 [5].  Открывается ранее созданный файл "Шука" для вывода
   ─────────────────   в него строк от конца. Затем программная строка 50
формирует очередные строки файла.По мере заполнения буфера данные выводят-
ся на дискету,а за последней строкой ставится метка окончания файла (EOF).
   20 OPEN "Щука" FOR APPEND AS#1
   30 INPUT"A=";A:INPUT"B$=";B$:INPUT"C=";C
   50 PRINT #1,A;",";B$;",";C
   55 IF C<>0 THEN 30 ELSE CLOSE #1

   П р и м е р 4 [5].  Открывается  новый или ранее  созданный  файл  "Ка-
   ─────────────────   рась" для вывода в него строк от  начала  и  далее.
Двумя командами 50 и 60 формируется строка.
   10 CLEAR 1000:MAXFILES=2:OPEN "Карась" FOR OUTPUT AS#2
   30 A$="FLOPPY DISK":E=45:F=54.8
   50 PRINT #2,A$;",";         '◀── Последний символ ";" !
   60 PRINT #2,E;",";F         '◀── Последний символ "пробел" !
   70 CLOSE #2

   П р и м е р 5 [5].  В файл "Карп" от его начала  с  клавиатуры  вводит-
   ─────────────────   ся S элементов числового массива.
   10 MAXFILES=5:OPEN "Карп" FOR OUTPUT AS#4
   30 INPUT "Количество элементов";S
   40 FOR K=1 TO S:INPUT M:PRINT #4,M;",";:NEXT K
   50 CLOSE #4

   П р и м е р 6 [5].  При формировании строки в качестве разделителей ис-
   ─────────────────   пользуется символ ", задаваемый кодом  CHR$(34).
   20 OPEN "Сазан" FOR OUTPUT AS#1
   30 R=123.789:K$="КRA,,N;W2"
   40 I$=CHR$(34)
   50 PRINT #1,R;",";I$;K$;I$
   60 CLOSE #1

   Оператор PRINT#,USING записывается в таком виде:
                        ┌─────────────────────────┐
                        │    PRINT #n,USING T,S   │ ,
                        └─────────────────────────┘
где: PRINT, USING - служебные слова;
     T - строковое выражение, значение которого определяет формат вывода;
     n - арифметическое выражение, целая часть значения которого определя-
ет номер контрольного буфера файла;
     S - список арифметических и (или) строковых выражений:
                              γ1, γ2,..., γk.
   При выполнении данного оператора значения выражений
                                γi    (i=1,2,...,k)
выводятся в соответствии с форматом T в буфер точно так же, как это "дела-
ет" "обычный" оператор PRINT USING .

   П р и м е р  7. 
   ──────────────
   10 CLEAR 1000:MAXFILES=5:DIM M(200)
   20 OPEN "Лещ" FOR OUTPUT AS#4
   30 INPUT"Количество элементов";S
   40 FOR K=1 TO S:X=INT(RND(1)*3000)/99:PRINT #4,USING "###.##";X:NEXT K
   50 CLOSE #4

   Однако, следует весьма осторожно употреблять префиксы, обозначающие де-
нежные единицы ("$$","**" и "**$"), так как  они  вызывают форматирование
числовых величин как нечисловых. По этой причине числовые  величины, снаб-
женные в дисковом файле такими префиксами, не могут быть считаны оттуда в
их исходном виде.

   П р и м е р  8.
   ──────────────
   10 OPEN "SAMPLE.DAT" FOR OUTPUT AS #1
   20 PRINT #1,USING"$$###.##";99.50:CLOSE#1
   40 OPEN "SAMPLE.DAT" FOR INPUT AS#1
   50 INPUT #1,A:PRINT"Первое значение в файле:";A:CLOSE#1
   run
   Первое значение в файле: 0
   Ok

   Пусть открыт файл  B , связанный с буфером FCBn.
   Функция                  ┌───────────────┐
                            │     LOF(n)    │ ,
                            └───────────────┘
где:  LOF("Length Of File"-"размер файла") - служебное слово;
      n - арифметическое выражение, целая часть значения которого  принад-
лежит отрезку [0,15] и определяет FCB, соответствующий файлу B,
возвращает размер файла B в байтах.
                            ┌───────────────┐
    Функция                 │     LOC(n)    │ ,
                            └───────────────┘
где:  LOC ("LOCation"-"определение позиции") - служебное слово;
      n - арифметическое выражение, целая часть значения которого  принад-
лежит отрезку [0,15] и определяет FCB, соответствующий файлу B,
для файлов последовательного доступа возвращает текущее количество байтов
информации, считанных в буфер или записанных на дискету.


           IX.3.3.   О п е р а т о р ы  INPUT, LINE INPUT #n .
                        Ф у н к ц и и  INPUT$ и EOF

   Для чтения строк файла последовательного доступа с дискеты  в оператив-
ную память используются операторы INPUT#, LINE INPUT# и функции INPUT$  и
EOF.
   Оператор               ┌──────────────────────┐
                          │    LINE INPUT #n,γ   │ ,
                          └──────────────────────┘
где:  LINE, INPUT - служебные слова;
      n - арифметическое выражение, целая часть значения которого  опреде-
ляет номер контрольного буфера файла;
      γ - строковая переменная,
позволяет считать очередную строку файла β, связанного с буфером n, и при-
своить результат переменной γ.

   Оператор LINEINPUT# , считывающий одиночное строковое  значение, позво-
ляет решить "проблему запятой".

   П р и м е р  1.
   ──────────────
   10 OPEN "TEST.DAT" FOR OUTPUT AS #1
   20 PRINT #1,"Агибалова, Алевтина":CLOSE#1
   40 OPEN "TEST.DAT" FOR INPUT AS#1
   50 LINE INPUT#1,A$:PRINT"Первое значение в файле:";A$:CLOSE#1
   run
   Первое значение в файле: Агибалова, Алевтина
   Ok

   П р и м е р  2.
   ──────────────
    10 CLEAR 1000:MAXFILES=5:DIM M(200)
    20 OPEN "LINP" FOR OUTPUT AS#4
    30 INPUT"Количество элементов";S
    40 FOR K=1 TO S:PRINT #4,K;",";:PRINT LOC(4);:NEXT K:CLOSE #4
    70 OPEN "LINP" FOR INPUT AS#4
    80 PRINT:PRINT LOF(4)
    90 LINE INPUT #4,M$
    100 PRINT LOC(4),:PRINT M$
    110 IF NOT EOF(4) THEN 90    'Обратите внимание на данную строку!
    120 PRINT LOF(4):CLOSE #4

   Оператор INPUT# записывается в виде
                           ┌─────────────────┐
                           │    INPUT #n,S   │ ,
                           └─────────────────┘
где: INPUT - служебное слово;
     n - арифметическое выражение, целая часть значения которого определя-
ет номер контрольного буфера файла;
     S - список переменных.
   Опишем, как происходит выполнение этого оператора.
   Если очередная считываемая строка файла состоит из значений:
                              α1, α2,..., αk,
то в соответствующей команде INPUT# список S должен иметь такой вид:
                              β1, β2,..., βk,
а каждая переменная βi обязана быть того же типа,что и значение αi.В этом
случае выполнение оператора приводит к присваиваниям переменным  βi значе-
ний αi.

   П р и м е р  3.  Чтение из файла последовательного доступа.
   ──────────────
   10 OPEN "GAMES" FOR INPUT AS #2
   20 FOR X=1 TO 5:INPUT #2,G$:PRINT G$:NEXT X:CLOSE #2
   run
   Футбол
   Гольф
   Баскетбол
   Хоккей
   Регби
   Ok

   П р и м е р  4.
   ──────────────
   10 OPEN "SAMPLE.DAT" FOR OUTPUT AS #1
   20 PRINT #1,12,567:CLOSE#1
   40 OPEN "SAMPLE.DAT" FOR INPUT AS#1
   50 INPUT #1,A,B:PRINT"Второе значение в файле:";B:CLOSE#1
   run
   Второе значение в файле: 567
   Ok

   П р и м е р  5.
   ──────────────
   10 OPEN "TEST.DAT" FOR OUTPUT AS #1
   20 PRINT #1,"Кремний";14;28.0855:CLOSE#1
   40 OPEN "TEST.DAT" FOR INPUT AS#1
   50 FOR K%=1 TO 3:INPUT#1,A$:PRINT"Значение номер";K%;":";A$:NEXT K%
   70 CLOSE#1
   run
   Значение номер 1: Кремний 14 28.0855
   Input past end in 50
   Ok

   При выполнении оператора PRINT# (строка 20) в  файл  записываются  три
различных значения, но поскольку в операторе  они  разделяются  символами
";", в файл они будут заноситься без разделителей. Когда оператор  INPUT#
реализует считывание этих значений (строка 50), они все "сливаются" в  од-
но. Таким образом, в файле не будет существовать ни второго, ни  третьего 
значений, поэтому при попытке чтения программой какой-либо информации  за
последним значением в файле фиксируется ошибка "Считывание  за  пределами
последнего значения".
   Разделителем для строковых данных может быть запятая или  символ  "Воз-
врат каретки". Те же самые знаки или пробелы служат для разграничения чис-
ловых величин. Существует несколько способов гарантированной  расстановки
разделителей между отдельными значениями. Один из самых простых состоит в
том, чтобы присвоить значение "," строковой переменной и записывать ее по-
сле каждого значения в операторе PRINT# .

   П р и м е р  6.
   ──────────────
   10 OPEN "TEST.DAT" FOR OUTPUT AS #1
   15 D$=",":PRINT#1,"Кремний";D$;14;D$;28.0855:CLOSE#1
   40 OPEN "TEST.DAT" FOR INPUT AS#1
   50 FOR K%=1 TO 3:INPUT #1,A$:PRINT"Значение номер";K%;":";A$:NEXT K%
   70 CLOSE#1
   run
   Значение номер 1: Кремний
   Значение номер 2: 14
   Значение номер 3: 28.0855
   Ok

   Отметим, что строковая величина в дисковом файле, могущая содержать за-
пятую, должна быть  записана  в  кавычках; оператор  INPUT#  обеспечивает
устранение этих кавычек при считывании.

   П р и м е р  7.
   ──────────────
   10 OPEN "TEST.DAT" FOR OUTPUT AS #1
   20 PRINT#1,CHR$(34);"Манагуа, Никарагуа";CHR$(34):CLOSE#1
   40 OPEN "TEST.DAT" FOR INPUT AS#1
   50 INPUT#1,A$:PRINT"Первое значение в файле:";A$:CLOSE#1
   run
   Первое значение в файле: Манагуа, Никарагуа
   Ok

   П р и м е р  8[7]. О б н о в л е н и е файла последовательного доступа.
   ─────────────────
   10 OPEN "GAMES" FOR INPUT AS #1   'Открывается "старый" файл
   20 OPEN "GAMES2" FOR OUTPUT AS #2 'Открывается "новый" файл (пустой)
   30 FOR X=1 TO 5
   40    INPUT #1,F$
   50    IF F$="Баскетбол" THEN F$="Водное поло"
   60    PRINT #2,F$
   70 NEXT X
   80 CLOSE 1,2                      'Оба файла закрываются
   90 KILL"GAMES"                    'Удаление исходного файла
   100 NAME "GAMES2" AS "GAMES"      'Переименование "нового" файла

   П р и м е р  9. 
   ──────────────
   10 CLEAR 1000:MAXFILES=5:DIM M(200)
   20 OPEN "Шар" FOR OUTPUT AS#4:INPUT"Количество элементов";S
   40 FOR K=1 TO S
   50    X=RND(1):Y=RND(1)
   60    X$=CHR$(INT(RND(1)*31)+224):Y$=CHR$(INT(RND(1)*31)+224)
   70    PRINT #4,X$+Y$;",";X;",";Y;
   80 NEXT K:CLOSE #4
   90 OPEN "Шар" FOR INPUT AS#4
   100 INPUT #4,M$,A,B:PRINT M$;A,B
   120 IF NOT EOF(4) THEN 100
   130 CLOSE #4
   run
   Количество элементов? 5
   ВЯ  .59521943994623    .10658628050158
   КЩ  .73474759503023    .18426812909758
   ЫО  .63799556899423    .47041117641358
   ОВ  .18586284343823    .12951037284958
   ТМ  .02818381196223    .48775999680558
   Ok
  Заметим, что строка 100 в этом примере могла быть  заменена на один  из
фрагментов: 
    а) 100 INPUT #4,M$                b) 100 INPUT #4,M$
       101 INPUT #4,A,B                  101 INPUT #4,A
                                         102 INPUT #4,B

   Для чтения очередного фиксированного количества символов из файла  без
учета его разбиения на строки используется функция
                         ┌─────────────────────┐
                         │   INPUT$(m[,[#]n])  │ ,
                         └─────────────────────┘
где:  INPUT$ - служебное слово;
      m  - арифметическое выражение, целая часть значения которого должна
принадлежать отрезку [1,255];
      n  - номер контрольного буфера файла.
   В любой момент работы с файлом функция INPUT$ "читает" INT(m) его  оче-
редных символов. Иными словами, последовательность этих символов становит-
ся значением функции INPUT$(). При этом метки окончания строк  воспринима-
ются так же, как любые другие символы.
   Функция INPUT$ возвращает строку, содержащую заданное количество симво-
лов, прочитанных из файла.
   ┌─────────────────────────────────────────────────────────────────┐
   │  Все символы, включая разделители, передаются  в программу, за  │
   │  исключением специального символа с кодом ASCII &H1A , который  │
   │  воспринимается как признак конца файла и "прекращает  выполне- │
   │                          ние" функции                           │
   └─────────────────────────────────────────────────────────────────┘
   Функция INPUT$ предоставляет возможность последовательно выбирать сим-
волы из файла независимо от разделителей строк!
   Для полного уяснения семантики функции  INPUT$ рекомендуется "прогнать"
следующий пример при различных значениях параметров S и X.

   П р и м е р  10[5]. 
   ──────────────────
   10 CLEAR 1000:MAXFILES=5:DIM M(200)
   20 OPEN "ТОР" FOR OUTPUT AS#4
   30 INPUT "Количество элементов";S
   40 FOR K=1 TO S:PRINT #4,"L";",";"W";",":NEXT K:CLOSE #4
   70 OPEN "ТОР" FOR INPUT AS#4
   80 INPUT"Длина значения в INPUT$";X
   90 Y=(LOF(4)-1)/X: Z=(LOF(4)-1)MOD X
   105 IF Y=0 THEN 130
   106 FOR K=1 TO Y
   110 X$=INPUT$(X,#4):PRINT X$
   115 NEXT
   120 IF Z=0 THEN 140
   130 PRINT INPUT$(Z,#4)
   140 CLOSE #4

   Заметим, что "длину" файла не всегда можно определить заранее: предста-
вьте себе файл адресов, который все время приходится открывать  в  режиме
добавления данных (FOR APPEND). Функция EOF позволяет Вам решить эту проб-
лему: специальный символ с кодом &h1А добавляется  к  концу  файла, когда
этот файл закрывается. Этот символ помечает  к о н е ц  файла.
   Функция  EOF , синтаксис которой
                              ┌──────────────┐
                              │     EOF(n)   │ ,
                              └──────────────┘
где: EOF ("End Of File" - "конец файла") - служебное слово;
     n - арифметическое выражение, целая часть значения которого определя-
ет номер файла,
сравнивает код очередного символа с кодом &h1А и возвращает:
   -1 ("true"), если найден код конца файла, и
    0 ("false") в противном случае.

   П р и м е р  11.  Продемонстрируем способ использования функции EOF().
   ───────────────
   10 OPEN "TESTF" FOR INPUT AS #1
   20 IF EOF(1) THEN 60	
   30 INPUT #1,A:PRINT A:GOTO 20
   60 CLOSE #1
   Ниже приведены 3 схемы, определяющие последовательность операций, кото-
рые должны быть выполнены при перемещениях строк файлов п о с л е д о в а-
т е л ь н о г о  д о с т у п а  из оперативной памяти на дискету  и  в об-
ратном направлении.
┌───────────────────────────────────────────────────────────────────────┐
│ 1. Общая схема формирования строк на диске от  н а ч а л а  файла  В: │
│    А. В оперативной памяти резервируется буфер (оператором MAXFILES=).│
│    B. Открывается новый или уже существующий файл В (оператором OPEN  │
│       с параметром  OUTPUT).                                          │
│    C. Формируется требуемое количество строк файла(операторами PRINT# │
│       или PRINT#,USING). На дискету из буфера они сбрасываются автома-│
│       тически.                                                        │
│    D. Файл В закрывается.                                             │
└───────────────────────────────────────────────────────────────────────┘

